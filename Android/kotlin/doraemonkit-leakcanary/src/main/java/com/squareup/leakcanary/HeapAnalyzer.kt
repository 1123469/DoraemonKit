/*
 * Copyright (C) 2015 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squareup.leakcanary

import android.os.Build.VERSION
import android.os.Build.VERSION_CODES
import com.squareup.haha.perflib.*
import com.squareup.haha.perflib.io.HprofBuffer
import com.squareup.haha.perflib.io.MemoryMappedFileBuffer
import com.squareup.leakcanary.AnalysisResult.Companion.failure
import com.squareup.leakcanary.AnalysisResult.Companion.leakDetected
import com.squareup.leakcanary.AnalysisResult.Companion.noLeak
import com.squareup.leakcanary.AnalyzerProgressListener
import gnu.trove.THashMap
import gnu.trove.TObjectProcedure
import java.io.File
import java.util.*
import java.util.concurrent.TimeUnit

/**
 * Analyzes heap dumps generated by a [RefWatcher] to verify if suspected leaks are real.
 */
class HeapAnalyzer(private val excludedRefs: ExcludedRefs,
                   private val listener: AnalyzerProgressListener,
                   reachabilityInspectorClasses: List<Class<out Reachability.Inspector>>) {
    private val reachabilityInspectors: MutableList<Reachability.Inspector>

    @Deprecated("Use {@link #HeapAnalyzer(ExcludedRefs, AnalyzerProgressListener, List)}.")
    constructor(excludedRefs: ExcludedRefs) : this(excludedRefs, AnalyzerProgressListener.NONE, emptyList<Class<out Reachability.Inspector>>()) {
    }

    fun findTrackedReferences(heapDumpFile: File): List<TrackedReference> {
        require(heapDumpFile.exists()) { "File does not exist: $heapDumpFile" }
        return try {
            val buffer: HprofBuffer = MemoryMappedFileBuffer(heapDumpFile)
            val parser = HprofParser(buffer)
            val snapshot = parser.parse()
            deduplicateGcRoots(snapshot)
            val refClass = snapshot.findClass(KeyedWeakReference::class.java.name)
            val references: MutableList<TrackedReference> = ArrayList()
            for (weakRef in refClass.instancesList) {
                val values = HahaHelper.classInstanceValues(weakRef)
                val key = HahaHelper.asString(HahaHelper.fieldValue(values, "key"))
                val name = if (HahaHelper.hasField(values, "name")) HahaHelper.asString(HahaHelper.fieldValue(values, "name")) else "(No name field)"
                val instance = HahaHelper.fieldValue<Instance>(values, "referent")
                if (instance != null) {
                    val className = getClassName(instance)
                    val fields = describeFields(instance)
                    references.add(TrackedReference(key, name, className, fields))
                }
            }
            references
        } catch (e: Throwable) {
            throw RuntimeException(e)
        }
    }

    /**
     * Calls [.checkForLeak] with computeRetainedSize set to true.
     *
     */
    @Deprecated("Use {@link #checkForLeak(File, String, boolean)} instead.")
    fun checkForLeak(heapDumpFile: File,
                     referenceKey: String): AnalysisResult {
        return checkForLeak(heapDumpFile, referenceKey, true)
    }

    /**
     * Searches the heap dump for a [KeyedWeakReference] instance with the corresponding key,
     * and then computes the shortest strong reference path from that instance to the GC roots.
     */
    fun checkForLeak(heapDumpFile: File,
                     referenceKey: String,
                     computeRetainedSize: Boolean): AnalysisResult {
        val analysisStartNanoTime = System.nanoTime()
        if (!heapDumpFile.exists()) {
            val exception: Exception = IllegalArgumentException("File does not exist: $heapDumpFile")
            return failure(exception, since(analysisStartNanoTime))
        }
        return try {
            listener.onProgressUpdate(AnalyzerProgressListener.Step.READING_HEAP_DUMP_FILE)
            val buffer: HprofBuffer = MemoryMappedFileBuffer(heapDumpFile)
            val parser = HprofParser(buffer)
            listener.onProgressUpdate(AnalyzerProgressListener.Step.PARSING_HEAP_DUMP)
            val snapshot = parser.parse()
            listener.onProgressUpdate(AnalyzerProgressListener.Step.DEDUPLICATING_GC_ROOTS)
            deduplicateGcRoots(snapshot)
            listener.onProgressUpdate(AnalyzerProgressListener.Step.FINDING_LEAKING_REF)
            val leakingRef = findLeakingReference(referenceKey, snapshot)

            // False alarm, weak reference was cleared in between key check and heap dump.
            if (leakingRef == null) {
                val className = leakingRef.getClassObj().getClassName()
                return noLeak(className, since(analysisStartNanoTime))
            }
            findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize)
        } catch (e: Throwable) {
            failure(e, since(analysisStartNanoTime))
        }
    }

    /**
     * 以前检查一遍 避免出现dokit内部的异常
     *
     * @param heapDumpFile
     * @param referenceKey
     * @return
     */
    fun preCheckForLeak(heapDumpFile: File,
                        referenceKey: String): Instance? {
        if (!heapDumpFile.exists()) {
            return null
        }
        val leakingRef: Instance
        leakingRef = try {
            val buffer: HprofBuffer = MemoryMappedFileBuffer(heapDumpFile)
            val parser = HprofParser(buffer)
            val snapshot = parser.parse()
            deduplicateGcRoots(snapshot)
            findLeakingReference(referenceKey, snapshot)
        } catch (e: Exception) {
            return null
        }
        return leakingRef
    }

    /**
     * Pruning duplicates reduces memory pressure from hprof bloat added in Marshmallow.
     */
    fun deduplicateGcRoots(snapshot: Snapshot) {
        // THashMap has a smaller memory footprint than HashMap.
        val uniqueRootMap = THashMap<String, RootObj?>()
        val gcRoots = snapshot.gcRoots
        for (root in gcRoots) {
            val key = generateRootKey(root)
            if (!uniqueRootMap.containsKey(key)) {
                uniqueRootMap[key] = root
            }
        }

        // Repopulate snapshot with unique GC roots.
        gcRoots.clear()
        uniqueRootMap.forEach(TObjectProcedure { key -> gcRoots.add(uniqueRootMap[key]) })
    }

    private fun generateRootKey(root: RootObj?): String {
        return String.format("%s@0x%08x", root!!.rootType.getName(), root.id)
    }

    private fun findLeakingReference(key: String, snapshot: Snapshot): Instance {
        val refClass = snapshot.findClass(KeyedWeakReference::class.java.name)
                ?: throw IllegalStateException(
                        "Could not find the " + KeyedWeakReference::class.java.name + " class in the heap dump.")
        val keysFound: MutableList<String?> = ArrayList()
        for (instance in refClass.instancesList) {
            val values = HahaHelper.classInstanceValues(instance)
            val keyFieldValue = HahaHelper.fieldValue<Any>(values, "key")
            if (keyFieldValue == null) {
                keysFound.add(null)
                continue
            }
            val keyCandidate = HahaHelper.asString(keyFieldValue)
            if (keyCandidate == key) {
                return HahaHelper.fieldValue(values, "referent")
            }
            keysFound.add(keyCandidate)
        }
        throw IllegalStateException(
                "Could not find weak reference with key $key in $keysFound")
    }

    private fun findLeakTrace(analysisStartNanoTime: Long, snapshot: Snapshot,
                              leakingRef: Instance, computeRetainedSize: Boolean): AnalysisResult {
        listener.onProgressUpdate(AnalyzerProgressListener.Step.FINDING_SHORTEST_PATH)
        val pathFinder = ShortestPathFinder(excludedRefs)
        val result = pathFinder.findPath(snapshot, leakingRef)
        val className = leakingRef.classObj.className

        // False alarm, no strong reference path to GC Roots.
        if (result.leakingNode == null) {
            return noLeak(className, since(analysisStartNanoTime))
        }
        listener.onProgressUpdate(AnalyzerProgressListener.Step.BUILDING_LEAK_TRACE)
        val leakTrace = buildLeakTrace(result.leakingNode)
        var retainedSize: Long
        if (computeRetainedSize) {
            listener.onProgressUpdate(AnalyzerProgressListener.Step.COMPUTING_DOMINATORS)
            // Side effect: computes retained size.
            snapshot.computeDominators()
            val leakingInstance = result.leakingNode.instance
            retainedSize = leakingInstance?.totalRetainedSize!!
            if (VERSION.SDK_INT <= VERSION_CODES.N_MR1) {
                listener.onProgressUpdate(AnalyzerProgressListener.Step.COMPUTING_BITMAP_SIZE)
                retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance!!)
            }
        } else {
            retainedSize = AnalysisResult.RETAINED_HEAP_SKIPPED
        }
        return leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,
                since(analysisStartNanoTime))
    }

    /**
     * Bitmaps and bitmap byte arrays are sometimes held by native gc roots, so they aren't included
     * in the retained size because their root dominator is a native gc root.
     * To fix this, we check if the leaking instance is a dominator for each bitmap instance and then
     * add the bitmap size.
     *
     *
     * From experience, we've found that bitmap created in code (Bitmap.createBitmap()) are correctly
     * accounted for, however bitmaps set in layouts are not.
     */
    private fun computeIgnoredBitmapRetainedSize(snapshot: Snapshot, leakingInstance: Instance): Long {
        var bitmapRetainedSize: Long = 0
        val bitmapClass = snapshot.findClass("android.graphics.Bitmap")
        for (bitmapInstance in bitmapClass.instancesList) {
            if (isIgnoredDominator(leakingInstance, bitmapInstance)) {
                val mBufferInstance = HahaHelper.fieldValue<ArrayInstance>(HahaHelper.classInstanceValues(bitmapInstance), "mBuffer")
                        ?: continue
                // Native bitmaps have mBuffer set to null. We sadly can't account for them.
                val bufferSize = mBufferInstance.totalRetainedSize
                var bitmapSize = bitmapInstance.totalRetainedSize
                // Sometimes the size of the buffer isn't accounted for in the bitmap retained size. Since
                // the buffer is large, it's easy to detect by checking for bitmap size < buffer size.
                if (bitmapSize < bufferSize) {
                    bitmapSize += bufferSize
                }
                bitmapRetainedSize += bitmapSize
            }
        }
        return bitmapRetainedSize
    }

    private fun isIgnoredDominator(dominator: Instance, instance: Instance): Boolean {
        var instance: Instance? = instance
        var foundNativeRoot = false
        while (true) {
            val immediateDominator = instance!!.immediateDominator
            if (immediateDominator is RootObj
                    && immediateDominator.rootType == RootType.UNKNOWN) {
                // Ignore native roots
                instance = instance.nextInstanceToGcRoot
                foundNativeRoot = true
            } else {
                instance = immediateDominator
            }
            if (instance == null) {
                return false
            }
            if (instance === dominator) {
                return foundNativeRoot
            }
        }
    }

    private fun buildLeakTrace(leakingNode: LeakNode?): LeakTrace {
        val elements: ArrayList<LeakTraceElement> = ArrayList()
        // We iterate from the leak to the GC root
        var node: LeakNode? = LeakNode(null, null, leakingNode, null)
        while (node != null) {
            val element = buildLeakElement(node)
            if (element != null) {
                elements.add(0, element)
            }
            node = node.parent
        }
        val expectedReachability = computeExpectedReachability(elements)
        return LeakTrace(elements, expectedReachability)
    }

    private fun computeExpectedReachability(
            elements: List<LeakTraceElement>): List<Reachability> {
        var lastReachableElement = 0
        val lastElementIndex = elements.size - 1
        var firstUnreachableElement = lastElementIndex
        // No need to inspect the first and last element. We know the first should be reachable (gc
        // root) and the last should be unreachable (watched instance).
        elementLoop@ for (i in 1 until lastElementIndex) {
            val element = elements[i]
            for (reachabilityInspector in reachabilityInspectors) {
                val reachability = reachabilityInspector.expectedReachability(element)
                if (reachability === Reachability.REACHABLE) {
                    lastReachableElement = i
                    break
                } else if (reachability === Reachability.UNREACHABLE) {
                    firstUnreachableElement = i
                    break@elementLoop
                }
            }
        }
        val expectedReachability: MutableList<Reachability> = ArrayList()
        for (i in elements.indices) {
            var status: Reachability
            status = if (i <= lastReachableElement) {
                Reachability.REACHABLE
            } else if (i >= firstUnreachableElement) {
                Reachability.UNREACHABLE
            } else {
                Reachability.UNKNOWN
            }
            expectedReachability.add(status)
        }
        return expectedReachability
    }

    private fun buildLeakElement(node: LeakNode): LeakTraceElement? {
        if (node.parent == null) {
            // Ignore any root node.
            return null
        }
        val holder = node.parent.instance
        if (holder is RootObj) {
            return null
        }
        val holderType: LeakTraceElement.Holder
        val className: String
        var extra: String? = null
        val leakReferences = describeFields(holder!!)
        className = getClassName(holder)
        val classHierarchy: MutableList<String> = ArrayList()
        classHierarchy.add(className)
        val rootClassName = Any::class.java.name
        if (holder is ClassInstance) {
            var classObj = holder.getClassObj()
            while (classObj.superClassObj.also { classObj = it }.className != rootClassName) {
                classHierarchy.add(classObj.className)
            }
        }
        if (holder is ClassObj) {
            holderType = LeakTraceElement.Holder.CLASS
        } else if (holder is ArrayInstance) {
            holderType = LeakTraceElement.Holder.ARRAY
        } else {
            val classObj = holder.classObj
            if (HahaHelper.extendsThread(classObj)) {
                holderType = LeakTraceElement.Holder.THREAD
                val threadName = HahaHelper.threadName(holder)
                extra = "(named '$threadName')"
            } else if (className.matches(Regex(ANONYMOUS_CLASS_NAME_PATTERN))) {
                val parentClassName = classObj.superClassObj.className
                if (rootClassName == parentClassName) {
                    holderType = LeakTraceElement.Holder.OBJECT
                    try {
                        // This is an anonymous class implementing an interface. The API does not give access
                        // to the interfaces implemented by the class. We check if it's in the class path and
                        // use that instead.
                        val actualClass = Class.forName(classObj.className)
                        val interfaces = actualClass.interfaces
                        extra = if (interfaces.size > 0) {
                            val implementedInterface = interfaces[0]
                            "(anonymous implementation of " + implementedInterface.name + ")"
                        } else {
                            "(anonymous subclass of java.lang.Object)"
                        }
                    } catch (ignored: ClassNotFoundException) {
                    }
                } else {
                    holderType = LeakTraceElement.Holder.OBJECT
                    // Makes it easier to figure out which anonymous class we're looking at.
                    extra = "(anonymous subclass of $parentClassName)"
                }
            } else {
                holderType = LeakTraceElement.Holder.OBJECT
            }
        }
        return LeakTraceElement(node.leakReference, holderType, classHierarchy, extra,
                node.exclusion, leakReferences)
    }

    private fun describeFields(instance: Instance): List<LeakReference> {
        val leakReferences: MutableList<LeakReference> = ArrayList()
        if (instance is ClassObj) {
            for ((key, value) in instance.staticFieldValues) {
                val name = key.name
                val stringValue = HahaHelper.valueAsString(value)
                leakReferences.add(LeakReference(LeakTraceElement.Type.STATIC_FIELD, name, stringValue))
            }
        } else if (instance is ArrayInstance) {
            val arrayInstance = instance
            if (arrayInstance.arrayType == Type.OBJECT) {
                val values = arrayInstance.values
                for (i in values.indices) {
                    val name = Integer.toString(i)
                    val stringValue = HahaHelper.valueAsString(values[i])
                    leakReferences.add(LeakReference(LeakTraceElement.Type.ARRAY_ENTRY, name, stringValue))
                }
            }
        } else {
            val classObj = instance.classObj
            for ((key, value) in classObj.staticFieldValues) {
                val name = key.name
                val stringValue = HahaHelper.valueAsString(value)
                leakReferences.add(LeakReference(LeakTraceElement.Type.STATIC_FIELD, name, stringValue))
            }
            val classInstance = instance as ClassInstance
            for (field in classInstance.values) {
                val name = field.field.name
                val stringValue = HahaHelper.valueAsString(field.value)
                leakReferences.add(LeakReference(LeakTraceElement.Type.INSTANCE_FIELD, name, stringValue))
            }
        }
        return leakReferences
    }

    private fun getClassName(instance: Instance): String {
        val className: String
        className = if (instance is ClassObj) {
            instance.className
        } else if (instance is ArrayInstance) {
            instance.classObj.className
        } else {
            val classObj = instance.classObj
            classObj.className
        }
        return className
    }

    private fun since(analysisStartNanoTime: Long): Long {
        return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime)
    }

    companion object {
        private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
    }

    init {
        reachabilityInspectors = ArrayList()
        for (reachabilityInspectorClass in reachabilityInspectorClasses) {
            try {
                val defaultConstructor = reachabilityInspectorClass.getDeclaredConstructor()
                reachabilityInspectors.add(defaultConstructor.newInstance())
            } catch (e: Exception) {
                throw RuntimeException(e)
            }
        }
    }
}